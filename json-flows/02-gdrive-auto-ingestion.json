{
  "name": "Google Drive Auto-Ingestion - idudesRAG",
  "nodes": [
    {
      "parameters": {
        "folderId": "YOUR_GOOGLE_DRIVE_FOLDER_ID",
        "triggerOn": "fileCreated",
        "options": {
          "includePermissions": false
        }
      },
      "id": "c5c6b2e0-8c4a-11ef-9f7a-0242ac120002",
      "name": "Google Drive Trigger",
      "type": "n8n-nodes-base.googleDriveTrigger",
      "typeVersion": 3,
      "position": [
        240,
        300
      ],
      "credentials": {
        "googleDriveOAuth2": {
          "id": "GOOGLE_DRIVE_OAUTH_CREDENTIAL_ID",
          "name": "Google Drive OAuth - idudesRAG"
        }
      }
    },
    {
      "parameters": {
        "operation": "download",
        "fileId": "={{ $json.id }}",
        "options": {
          "googleFileConversion": {
            "conversion": {
              "docsToFormat": "text/plain",
              "sheetsToFormat": "text/csv",
              "slidesToFormat": "text/plain"
            }
          }
        }
      },
      "id": "d1d2b3e0-8c4a-11ef-9f7a-0242ac120003",
      "name": "Download File",
      "type": "n8n-nodes-base.googleDrive",
      "typeVersion": 3,
      "position": [
        460,
        300
      ],
      "credentials": {
        "googleDriveOAuth2": {
          "id": "GOOGLE_DRIVE_OAUTH_CREDENTIAL_ID",
          "name": "Google Drive OAuth - idudesRAG"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "const input = $input.first();\nlet content = '';\nlet filename = 'unknown';\nlet file_type = 'text/plain';\nlet file_size = 0;\nlet source = 'google_drive';\n\n// Extract metadata from Google Drive download node\nif (input.json?.name) filename = input.json.name;\nif (input.json?.mimeType) file_type = input.json.mimeType;\nif (input.json?.size) file_size = parseInt(input.json.size);\n\n// Extract and DECODE base64 content to text\nif (input.binary?.data) {\n  const fileData = input.binary.data;\n  \n  // Handle Buffer object - ALWAYS decode from base64 first\n  if (Buffer.isBuffer(fileData)) {\n    try {\n      // Try base64 decode first (Google Drive exports are base64 encoded)\n      content = Buffer.from(fileData.toString('utf-8'), 'base64').toString('utf-8');\n    } catch (e) {\n      // If base64 decode fails, just convert buffer to string\n      content = fileData.toString('utf-8');\n    }\n  }\n  // Handle string - check if base64 encoded\n  else if (typeof fileData === 'string') {\n    // If looks like base64, decode it\n    if (/^[A-Za-z0-9+/=]+$/.test(fileData) && fileData.length > 50) {\n      try {\n        content = Buffer.from(fileData, 'base64').toString('utf-8');\n      } catch (e) {\n        content = fileData;\n      }\n    } else {\n      content = fileData;\n    }\n  }\n  // Handle object (Google Docs API response)\n  else if (typeof fileData === 'object') {\n    if (fileData.data) {\n      content = Buffer.from(fileData.data, 'base64').toString('utf-8');\n    } else {\n      content = JSON.stringify(fileData);\n    }\n  }\n  // Fallback\n  else {\n    content = String(fileData);\n  }\n}\n\n// If still empty or [object Object], get from json.content or json.data\nif (!content || content === '[object Object]') {\n  if (input.json?.content) {\n    const raw = input.json.content;\n    if (typeof raw === 'string' && /^[A-Za-z0-9+/=]+$/.test(raw) && raw.length > 50) {\n      content = Buffer.from(raw, 'base64').toString('utf-8');\n    } else {\n      content = typeof raw === 'string' ? raw : JSON.stringify(raw);\n    }\n  } else if (input.json?.data) {\n    const raw = input.json.data;\n    if (typeof raw === 'string' && /^[A-Za-z0-9+/=]+$/.test(raw) && raw.length > 50) {\n      content = Buffer.from(raw, 'base64').toString('utf-8');\n    } else {\n      content = typeof raw === 'string' ? raw : JSON.stringify(raw);\n    }\n  }\n}\n\nreturn [{\n  json: {\n    pageContent: content,\n    metadata: {\n      filename: filename,\n      file_type: file_type,\n      file_size: file_size || content.length,\n      source: source,\n      timestamp: new Date().toISOString(),\n      upload_source: 'google_drive',\n      drive_file_id: input.json?.id || null\n    }\n  }\n}];\n"
      },
      "id": "e2e3c4f0-8c4a-11ef-9f7a-0242ac120004",
      "name": "PrepDoc",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        680,
        300
      ]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "INSERT INTO core.documents (filename, content, file_size, file_type, metadata)\nSELECT\n  (j->'metadata'->>'filename')::text,\n  (j->>'pageContent')::text,\n  COALESCE(NULLIF(j->'metadata'->>'file_size','')::bigint, 0),\n  (j->'metadata'->>'file_type')::text,\n  COALESCE((j->'metadata')::jsonb, '{}'::jsonb)\nFROM (SELECT $1::jsonb AS j) payload\nON CONFLICT (filename)\nDO UPDATE SET\n  content = EXCLUDED.content,\n  file_size = EXCLUDED.file_size,\n  file_type = EXCLUDED.file_type,\n  metadata = EXCLUDED.metadata,\n  updated_at = NOW() AT TIME ZONE 'America/Phoenix'\nRETURNING id, filename, created_at, updated_at;\n",
        "options": {
          "queryReplacement": "={{ JSON.stringify($json) }}"
        }
      },
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.6,
      "position": [
        900,
        300
      ],
      "id": "f3f4d5e0-8c4a-11ef-9f7a-0242ac120005",
      "name": "Execute a SQL query",
      "credentials": {
        "postgres": {
          "id": "jd4YBgZXwugV4pZz",
          "name": "RailwayPG-idudes"
        }
      }
    },
    {
      "parameters": {
        "mode": "raw",
        "jsonOutput": "={\n  \"pageContent\": \"{{ $('PrepDoc').first().json.pageContent }}\",\n  \"metadata\": {\n    \"filename\": \"{{ $('PrepDoc').first().json.metadata.filename }}\",\n    \"file_type\": \"{{ $('PrepDoc').first().json.metadata.file_type }}\",\n    \"file_size\": \"{{ $('PrepDoc').first().json.metadata.file_size }}\",\n    \"source\": \"{{ $('PrepDoc').first().json.metadata.source }}\",\n    \"timestamp\": \"{{ $('PrepDoc').first().json.metadata.timestamp }}\",\n    \"upload_source\": \"{{ $('PrepDoc').first().json.metadata.upload_source }}\",\n    \"drive_file_id\": \"{{ $('PrepDoc').first().json.metadata.drive_file_id }}\",\n    \"document_id\": \"{{ $('Execute a SQL query').first().json.id }}\"\n  }\n}",
        "options": {
          "dotNotation": true
        }
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        1120,
        300
      ],
      "id": "04051617-8c4b-11ef-9f7a-0242ac120006",
      "name": "Edit Fields"
    },
    {
      "parameters": {
        "jsCode": "// n8n Code node: map/normalize doc → PGVector-ready\n\n// --- helpers ---\nconst toInt = (v) => {\n  if (v === null || v === undefined) return 0;\n  const n = parseInt(String(v), 10);\n  return Number.isNaN(n) ? 0 : n;\n};\n\nconst asIso = (v) => {\n  try {\n    if (!v) return new Date().toISOString();\n    const d = new Date(v);\n    return isNaN(d.getTime()) ? new Date().toISOString() : d.toISOString();\n  } catch {\n    return new Date().toISOString();\n  }\n};\n\nconst isUuid = (v) =>\n  typeof v === 'string' &&\n  /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);\n\n// try to read DB id from the SQL node; safe if missing\nlet dbId;\ntry {\n  dbId = $('Execute a SQL query').first().json?.id;\n} catch (_) {\n  dbId = undefined;\n}\n\n// accept current items or fall back to PrepDoc\nlet raw = $input.all().map(i => i.json);\nif (raw.length === 0) {\n  try {\n    const p = $('PrepDoc').first().json;\n    if (p) raw = [p];\n  } catch (_) {}\n}\n\nconst out = [];\n\nfor (const doc of raw) {\n  const md = doc?.metadata ?? {};\n  const pageContent = String(doc?.pageContent ?? '');\n\n  // choose document_id priority: DB id → existing metadata\n  let document_id = dbId ?? md.document_id;\n  if (!isUuid(document_id)) document_id = undefined;\n\n  const mapped = {\n    pageContent,\n    metadata: {\n      filename: md.filename ?? 'unknown',\n      file_type: md.file_type ?? 'text/plain',\n      file_size: toInt(md.file_size ?? pageContent.length),\n      source: md.source ?? 'google_drive',\n      timestamp: asIso(md.timestamp),\n      upload_source: md.upload_source ?? 'google_drive',\n      drive_file_id: md.drive_file_id ?? null,\n      ...(document_id ? { document_id } : {})\n    }\n  };\n\n  out.push({ json: mapped });\n}\n\nconsole.log('Mapped docs →', JSON.stringify(out.map(i => i.json), null, 2));\nreturn out;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1340,
        300
      ],
      "id": "15162718-8c4b-11ef-9f7a-0242ac120007",
      "name": "map"
    },
    {
      "parameters": {
        "jsonMode": "expressionData",
        "jsonData": "={{ $('map').item.json.pageContent }}",
        "textSplittingMode": "custom",
        "options": {
          "metadata": {
            "metadataValues": [
              {
                "name": "filename",
                "value": "={{ $('map').first().json.metadata.filename }}"
              },
              {
                "name": "source",
                "value": "={{ $('map').first().json.metadata.source }}"
              },
              {
                "name": "file_type",
                "value": "={{ $('map').first().json.metadata.file_type }}"
              },
              {
                "name": "file_size",
                "value": "={{ $('map').first().json.metadata.file_size }}"
              },
              {
                "name": "timestamp",
                "value": "={{ $('map').first().json.metadata.timestamp }}"
              },
              {
                "name": "document_id",
                "value": "={{ $('map').first().json.metadata.document_id }}"
              },
              {
                "name": "drive_file_id",
                "value": "={{ $('map').first().json.metadata.drive_file_id }}"
              }
            ]
          }
        }
      },
      "type": "@n8n/n8n-nodes-langchain.documentDefaultDataLoader",
      "typeVersion": 1.1,
      "position": [
        1800,
        524
      ],
      "id": "26273819-8c4b-11ef-9f7a-0242ac120008",
      "name": "DocLoader"
    },
    {
      "parameters": {
        "chunkSize": 10000,
        "chunkOverlap": 200,
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.textSplitterRecursiveCharacterTextSplitter",
      "typeVersion": 1,
      "position": [
        1880,
        732
      ],
      "id": "37384920-8c4b-11ef-9f7a-0242ac120009",
      "name": "Text Splitter"
    },
    {
      "parameters": {
        "options": {
          "dimensions": 1536,
          "batchSize": 200
        }
      },
      "type": "@n8n/n8n-nodes-langchain.embeddingsOpenAi",
      "typeVersion": 1.2,
      "position": [
        1672,
        524
      ],
      "id": "48495a21-8c4b-11ef-9f7a-0242ac120010",
      "name": "Embeddings OpenAI",
      "credentials": {
        "openAiApi": {
          "id": "EQYdxPEgshiwvESa",
          "name": "ZARAapiKey"
        }
      }
    },
    {
      "parameters": {
        "mode": "insert",
        "tableName": "core.document_embeddings",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.vectorStorePGVector",
      "typeVersion": 1.3,
      "position": [
        1704,
        300
      ],
      "id": "59505b22-8c4b-11ef-9f7a-0242ac120011",
      "name": "PGVector Store",
      "credentials": {
        "postgres": {
          "id": "jd4YBgZXwugV4pZz",
          "name": "RailwayPG-idudes"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// FINAL VERSION - CLOSE DB CONNECTIONS NODE FOR n8n\n// Copy this entire code into a Code node (JavaScript) at the end of your workflow\n// This version works without external modules\n\n// 1. Clean up any global connection objects\nconst globalCleanup = () => {\n  const targets = ['pgPool', 'pgClient', 'dbConn', 'redisClient'];\n  let cleaned = 0;\n\n  targets.forEach(name => {\n    if (global[name]) {\n      try {\n        delete global[name];\n        cleaned++;\n      } catch (e) {\n        // Silent fail\n      }\n    }\n  });\n\n  return cleaned;\n};\n\n// 2. Generate cleanup report\nconst generateReport = (cleaned) => {\n  return {\n    workflow: $workflow.name || 'Unknown',\n    workflowId: $workflow.id,\n    execution: $execution.id,\n    timestamp: new Date().toISOString(),\n    connectionsCleared: cleaned,\n    status: 'success'\n  };\n};\n\n// 3. Execute cleanup\nconst cleaned = globalCleanup();\nconst report = generateReport(cleaned);\n\n// 4. Log the results\nconsole.log('🧹 Cleanup Complete:', JSON.stringify(report, null, 2));\n\n// 5. Pass through the data with cleanup metadata\nreturn $input.all().map(item => ({\n  ...item,\n  json: {\n    ...item.json,\n    _cleanup: report\n  }\n}));"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        2072,
        300
      ],
      "id": "60616c23-8c4b-11ef-9f7a-0242ac120012",
      "name": "Cleanup Connections"
    }
  ],
  "pinData": {},
  "connections": {
    "Google Drive Trigger": {
      "main": [
        [
          {
            "node": "Download File",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Download File": {
      "main": [
        [
          {
            "node": "PrepDoc",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "PrepDoc": {
      "main": [
        [
          {
            "node": "Execute a SQL query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Execute a SQL query": {
      "main": [
        [
          {
            "node": "Edit Fields",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Edit Fields": {
      "main": [
        [
          {
            "node": "map",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "map": {
      "main": [
        [
          {
            "node": "PGVector Store",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "DocLoader": {
      "ai_document": [
        [
          {
            "node": "PGVector Store",
            "type": "ai_document",
            "index": 0
          }
        ]
      ]
    },
    "Text Splitter": {
      "ai_textSplitter": [
        [
          {
            "node": "DocLoader",
            "type": "ai_textSplitter",
            "index": 0
          }
        ]
      ]
    },
    "Embeddings OpenAI": {
      "ai_embedding": [
        [
          {
            "node": "PGVector Store",
            "type": "ai_embedding",
            "index": 0
          }
        ]
      ]
    },
    "PGVector Store": {
      "main": [
        [
          {
            "node": "Cleanup Connections",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": {
      "errorWorkflow": "",
      "continueOnFail": false
    }
  },
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "ai.thirdeyediagnostics.com"
  },
  "id": "gdrive-auto-ingestion-idudes",
  "tags": [
    {
      "createdAt": "2025-10-06T00:00:00.000Z",
      "updatedAt": "2025-10-06T00:00:00.000Z",
      "id": "ingestion",
      "name": "ingestion"
    },
    {
      "createdAt": "2025-10-06T00:00:00.000Z", 
      "updatedAt": "2025-10-06T00:00:00.000Z",
      "id": "idudes",
      "name": "idudes"
    }
  ]
}